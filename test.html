<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>下落式音乐游戏 - 打击判定演示</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #222;
        font-family: Arial, sans-serif;
        overflow: hidden;
      }

      #gameContainer {
        position: relative;
        width: 800px;
        height: 600px;
      }

      #gameCanvas {
        background-color: #111;
        border-radius: 8px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }

      #stats {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-size: 16px;
      }

      #instructions {
        position: absolute;
        bottom: 20px;
        left: 20px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
      }
    </style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="stats">判定: <span id="judgementText">-</span> | 误差: <span id="errorText">-</span>ms | KPS: <span id="kpsText">0</span></div>
    <div id="instructions">按空格键模拟打击，音符会在1秒、1.5秒、2秒、2.8秒、3.5秒出现</div>
</div>

<script>
  // 判定类型定义
  const Judgement = {
    PERFECT: { name: "PERFECT", maxError: 20, priority: 0, color: "#FFD700", size: 72 },
    GREAT: { name: "GREAT", maxError: 50, priority: 1, color: "#00FF7F", size: 64 },
    GOOD: { name: "GOOD", maxError: 100, priority: 2, color: "#1E90FF", size: 56 },
    BAD: { name: "BAD", maxError: 150, priority: 3, color: "#FF8C00", size: 48 },
    POOR: { name: "POOR", maxError: 200, priority: 4, color: "#A9A9A9", size: 40 },
    MISS: { name: "MISS", maxError: Infinity, priority: 5, color: "#FF4500", size: 48 }
  };

  // 音符类
  class Note {
    constructor(time) {
      this.time = time; // 音符应该被击中的时间(毫秒)
      this.hit = false; // 是否已被击中
      this.judgement = null; // 击中判定结果
      this.hitTime = null; // 实际击中时间
    }
  }

  // 判定显示效果类
  class JudgementEffect {
    constructor(type, time) {
      this.type = type; // 判定类型
      this.startTime = time; // 开始显示的时间
      this.scale = 0; // 当前缩放值
      this.alpha = 1; // 透明度
      this.active = true; // 是否还在活跃
      this.maxScale = 1.0; // 最大缩放值
      this.yOffset = 0; // Y轴偏移(用于弹跳效果)
    }
  }

  // 游戏主类
  class RhythmGame {
    constructor() {
      this.canvas = document.getElementById('gameCanvas');
      this.ctx = this.canvas.getContext('2d');
      this.notes = []; // 所有音符
      this.activeEffects = []; // 正在显示的判定效果
      this.lastHitTimes = []; // 记录最近击中时间(用于计算KPS)
      this.currentTime = 0; // 当前游戏时间
      this.keyStates = {}; // 按键状态
      this.lastJudgement = null; // 上一次判定
      this.lastError = 0; // 上一次误差

      // 初始化游戏
      this.init();
    }

    init() {
      // 添加测试音符
      this.addNote(1000); // 1秒
      this.addNote(1500); // 1.5秒
      this.addNote(2000); // 2秒
      this.addNote(2800); // 2.8秒
      this.addNote(3500); // 3.5秒
      this.addNote(3600); // 3.5秒
      this.addNote(3700); // 3.5秒
      this.addNote(3800); // 3.5秒
      this.addNote(3900); // 3.5秒
      this.addNote(4000); // 3.5秒

      // 开始游戏循环
      requestAnimationFrame(this.gameLoop.bind(this));

      // 设置按键监听
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !this.keyStates['Space']) {
          this.keyStates['Space'] = true;
          this.checkHit(performance.now());
        }
      });

      document.addEventListener('keyup', (e) => {
        if (e.code === 'Space') {
          this.keyStates['Space'] = false;
        }
      });
    }

    // 添加音符
    addNote(time) {
      this.notes.push(new Note(time));
    }

    // 检查击中
    checkHit(currentTime) {
      // 计算KPS(每秒按键次数)
      this.lastHitTimes = this.lastHitTimes.filter(t => t > currentTime - 1000);
      const kps = this.lastHitTimes.length;
      const isHighKPS = kps >= 20;

      // 遍历未击中的音符
      for (let i = 0; i < this.notes.length; i++) {
        const note = this.notes[i];
        if (note.hit) continue;

        const timeDiff = Math.abs(currentTime - note.time);
        let judgement = null;

        // 确定判定类型
        if (timeDiff <= Judgement.PERFECT.maxError) {
          judgement = Judgement.PERFECT;
        } else if (timeDiff <= Judgement.GREAT.maxError) {
          judgement = Judgement.GREAT;
        } else if (timeDiff <= Judgement.GOOD.maxError) {
          judgement = Judgement.GOOD;
        } else if (timeDiff <= Judgement.BAD.maxError) {
          judgement = Judgement.BAD;
        } else if (timeDiff <= Judgement.POOR.maxError) {
          judgement = Judgement.POOR;
        } else {
          continue; // 超出最大判定范围
        }

        // 标记音符为已击中
        note.hit = true;
        note.judgement = judgement;
        note.hitTime = currentTime;

        // 添加判定效果
        const effect = new JudgementEffect(judgement, currentTime);
        if (isHighKPS) {
          effect.maxScale = 1.1;
        }
        this.activeEffects.push(effect);

        // 记录击中时间和更新统计
        this.lastHitTimes.push(currentTime);
        this.lastJudgement = judgement.name;
        this.lastError = timeDiff;
        this.updateStats();

        break; // 一次按键只处理一个音符
      }
    }

    // 更新游戏状态
    update(currentTime) {
      this.currentTime = currentTime;

      // 更新判定效果
      for (let i = 0; i < this.activeEffects.length; i++) {
        const effect = this.activeEffects[i];
        const elapsed = currentTime - effect.startTime;

        // 动画效果
        if (elapsed < 100) {
          // 0-100ms: 放大动画
          effect.scale = this.easeOutQuad(elapsed / 100) * effect.maxScale;
          effect.yOffset = 0;
        } else if (elapsed < 200) {
          // 100-200ms: 回弹动画
          effect.scale = effect.maxScale - this.easeInQuad((elapsed - 100) / 100) * 0.2;
          effect.yOffset = Math.sin((elapsed - 100) / 100 * Math.PI) * -20;
        } else if (elapsed < 500) {
          // 200-500ms: 渐隐
          effect.scale = effect.maxScale * 0.8;
          effect.alpha = 1 - (elapsed - 200) / 300;
          effect.yOffset = 0;
        } else {
          // 超过500ms: 移除效果
          effect.active = false;
        }
      }

      // 移除不活跃的效果
      this.activeEffects = this.activeEffects.filter(e => e.active);

      // 检查MISS(音符超过最大判定时间未被击中)
      for (const note of this.notes) {
        if (!note.hit && currentTime - note.time > Judgement.POOR.maxError) {
          note.hit = true;
          note.judgement = Judgement.MISS;
          const effect = new JudgementEffect(Judgement.MISS, currentTime);
          this.activeEffects.push(effect);

          // 更新统计
          this.lastJudgement = Judgement.MISS.name;
          this.lastError = currentTime - note.time;
          this.updateStats();
        }
      }
    }

    // 渲染
    render() {
      // 清空画布
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // 绘制音符轨道
      this.drawNoteTrack();

      // 绘制活跃的音符
      this.drawActiveNotes();

      // 渲染判定效果(按优先级排序)
      const sortedEffects = [...this.activeEffects].sort((a, b) =>
        b.type.priority - a.type.priority
      );

      for (const effect of sortedEffects) {
        this.renderJudgementEffect(effect);
      }
    }

    // 绘制音符轨道
    drawNoteTrack() {
      this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      this.ctx.fillRect(this.canvas.width / 2 - 50, 0, 100, this.canvas.height);

      // 绘制打击线
      this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.moveTo(0, this.canvas.height - 100);
      this.ctx.lineTo(this.canvas.width, this.canvas.height - 100);
      this.ctx.stroke();
    }

    // 绘制活跃的音符
    drawActiveNotes() {
      const hitLineY = this.canvas.height - 100;
      const noteWidth = 80;
      const noteHeight = 20;

      this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';

      for (const note of this.notes) {
        if (note.hit) continue;

        // 计算音符位置(从顶部下落)
        const timeDiff = this.currentTime - note.time;
        const speed = 0.3; // 像素/毫秒
        const y = hitLineY + timeDiff * speed;

        // 只绘制在屏幕内的音符
        if (y > -noteHeight && y < this.canvas.height) {
          this.ctx.fillRect(
            this.canvas.width / 2 - noteWidth / 2,
            y - noteHeight / 2,
            noteWidth,
            noteHeight
          );
        }
      }
    }

    // 渲染判定效果
    renderJudgementEffect(effect) {
      const centerX = this.canvas.width / 2;
      const centerY = this.canvas.height / 2 + effect.yOffset;

      this.ctx.save();
      this.ctx.globalAlpha = effect.alpha;
      this.ctx.fillStyle = effect.type.color;
      this.ctx.textAlign = 'center';
      this.ctx.textBaseline = 'middle';

      // 设置字体大小(基于基础大小和当前缩放)
      const fontSize = effect.type.size * effect.scale;
      this.ctx.font = `bold ${fontSize}px Arial`;

      // 添加文字阴影效果
      this.ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      this.ctx.shadowBlur = 10;
      this.ctx.shadowOffsetX = 2;
      this.ctx.shadowOffsetY = 2;

      this.ctx.fillText(effect.type.name, centerX, centerY);
      this.ctx.restore();
    }

    // 更新统计显示
    updateStats() {
      document.getElementById('judgementText').textContent = this.lastJudgement || '-';
      document.getElementById('errorText').textContent = this.lastError ? Math.round(this.lastError) : '-';
      document.getElementById('kpsText').textContent = this.lastHitTimes.filter(t => t > performance.now() - 1000).length;
    }

    // 缓动函数
    easeOutQuad(t) {
      return t * (2 - t);
    }

    easeInQuad(t) {
      return t * t;
    }

    // 游戏主循环
    gameLoop(timestamp) {
      this.update(timestamp);
      this.render();
      requestAnimationFrame(this.gameLoop.bind(this));
    }
  }

  // 启动游戏
  window.onload = () => {
    new RhythmGame();
  };
</script>
</body>
</html>
